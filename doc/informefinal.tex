\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage[pdftex,usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[table]{xcolor}
\usepackage[small,bf]{caption}
\usepackage{float}
\usepackage{subfig}
\usepackage{listings}
\usepackage{bm}
\usepackage{times}

\begin{document}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\renewcommand{\lstlistingname}{C\'odigo Fuente}
\lstloadlanguages{Octave} 
\lstdefinelanguage{MyOctave}[]{Octave}{
        deletekeywords={beta,det},
        morekeywords={repmat}
} 
\lstset{
        language=MyOctave,
        stringstyle=\ttfamily,
        showstringspaces = false,
        basicstyle=\footnotesize\ttfamily,
        commentstyle=\color{gray},
        keywordstyle=\bfseries,
        numbers=left,
        numberstyle=\ttfamily\footnotesize,
        stepnumber=1,                   
        framexleftmargin=0.20cm,
        numbersep=0.37cm,              
        backgroundcolor=\color{white},
        showspaces=false,
        showtabs=false,
        frame=l,
        tabsize=4,
        captionpos=b,               
        breaklines=true,             
        breakatwhitespace=false,      
        mathescape=true
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% begin TITLE PAGE %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
        \vfill
        \thispagestyle{empty}
        \begin{center}
                \includegraphics{./images/itba_logo.png}
                \vfill
                \Huge{Sistemas de Inteligencia Artificial}\\
                \vspace{1cm}
                \Huge{Métodos de búsqueda no informados y e informados}\\
                \vspace{1cm}
                \Huge{Trabajo Pr\'actico Especial 1}\\
        \end{center}
        \vfill
        \large{
        \begin{tabular}{lcr}
                Civile, Juan Pablo && 50453\\
                Ordano, Esteban && 50753\\
                Crespo, Alvaro && 50758 \\
        \end{tabular}
}
        \vspace{2cm}
        \begin{center}
                \large{6 de Junio de 2012}\\
        \end{center}
\end{titlepage}
\newpage

\setcounter{page}{1}

% \tableofcontents
% \newpage

\section{Definición del problema}

Definimos el tablero de juego como una matriz de números enteros, y cada número representa una ficha. Números distintos corresponden a fichas distintas. 
El objetivo del juego es vaciar el tablero, quitando todas las fichas. Las fichas se sacan de a pares, siempre siendo ambas del mismo tipo, y solamente pueden ser elegibles 
para ser sacadas del tablero si se encuentran en los bordes izquierdo o derecho del tablero. No hay necesidad de que ambas fichas esten en el mismo borde. Cabe destacar 
que podría ocurrir que en un determinado momento no haya posibilidad de quitar más fichas. En este caso, el juego se da por perdido.

\label{problem-info}
Representamos el proceso del juego como una sucesión de estados que están dispuestos en un grafo sin ciclos, o \textit{árbol}. Los estados están conectados si se puede pasar de uno 
al otro, haciendo un movimiento del juego \textit{válido}. Teniendo esto en cuenta, la raíz de nuestro árbol será el estado inicial, en el que tablero tiene todas sus fichas. Algo que 
se deduce de este planteo, es que todos los estados que estén a la misma altura $h$, tendrán la misma cantidad de fichas, por que para llegar a él hubo que realizar la misma cantidad 
de movimientos, $n$. Esto nos lleva a poder afirmar que todas las soluciones estarán a la misma altura (la máxima) y que esta altura es conocida para un tablero de $N$ fichas: es 
$\frac{N}{2}$, ya que en cada movimiento válido se pueden sacar solo 2 fichas.

\section{Heurísticas}

    \subsection{Primer heurística}
    
    Como primer heurística propusimos tomar en cuenta el mínimo entre la cantidad de estados que faltan para llegar a una solución (recordemos la información que tenemos del 
    problema según lo explicado en la sección \ref{problem-info}) y la productoria de la combinatoria 2,N 
    siendo N el tamaño de cada uno de los conjuntos de fichas iguales en los bordes izquierdo o derecho.\\

    La idea tras esta fórmula es recorrer primero las ramas del árbol que tengan más 

    Cabe destacar que por definición esta heurística es admisible.


    \[ h(x) = min(\text{\# estados que faltan}, \Pi_{n=0}^{N} { \text{tamaño conjunto n} \choose 2} )\] 

    siendo N la cantidad de conjuntos de fichas iguales en los bordes.
    
    \subsection{Segunda heurística}

    Como segunda heurística propusimos la sencilla resta entre la cantidad total de fichas restantes en el tablero y la cantidad de fichas con posibilidad de ser retiradas en el
    siguiente movimiento.\\

    Cabe destacar que por definición esta heurística es admisible.

     \[ h(x) = N - K\] 

    siendo N la cantidad total de fichas restantes en el tablero, y K la cantidad de fichas elegibles para ser retiradas del tablero.

    \subsection{Heurística trivial}

    La heurística trivial en nuestro caso, sería contar la cantidad de fichas que restan sacar del tablero. Esta heurística transforma el algoritmo A* en un simple DFS, ya que siempre 
    exploraría primero los nodos hijos.

    \[ h(x) = N \] 

    siendo N la cantidad total de fichas restantes en el tablero.

\section{Función de costo}

    Nuestra función de costo consta simplemente de contabilizar la cantidad de piezas que fueron removidas hasta llegar al estado en cuestión. Es la más sencilla y la que más sentido
    tiene, ya que se corresponde con la realidad. \\

\section{Búsquedas no informadas}

    \subsection{Depth First Search}
    Dada las características del problema, este es el algoritmo que mejor se comporta, ya que baja rápidamente por el árbol y tiene más posibilidades de encontrar una solución primero.
    Solución que será la aceptada porque como sabemos, todas las soluciones son igualmente buenas.
    
    \subsection{Breath First Search}
    En contraposición con el \textit{DFS}, este algoritmo tiene una perfomance pobre, ya que explora muchos estados de más, al hacer una búsqueda "a lo ancho". También le juega en 
    contra que en nuestro problema no existe una solución óptima o camino óptimo, o más bien, cualquier solución es óptima, y cualquier camino es óptimo. Por lo cual no nos interesa 
    demorarnos en analizar todos los caminos posibles.
    
    \subsection{Iterative Deepening}
    Como su definición lo dice, este algoritmo mezcla las características del \textit{DFS} con las del \textit{BFS}, por lo que en nuestro problema, tiene aspectos positivos (los del 
    \textit{DFS}) y también negativos (los del \textit{BFS}). 
 
\section{Búsquedas informadas}
    
    \subsection{Greedy Search}
    
    Este algoritmo, por definición, se centra en la heurística elegida y varía su perfomance de acuerdo a ella. En nuestro problema fue una de las mejores estrategias de resolución, 
    solo superada por \textit{DFS}.

    \subsection{A*}
    
    El algoritmo A* agrega a la función heurística, una función de costo, para contabilizar el costo o esfuerzo que tomó llegar hasta cierto estado. En nuestro problema tuvo una 
    perfomance decente, variando con el tipo de heurística elegida. Cabe destacar que en el caso de la heurística trivial, este algoritmo se transforma en un \textit{DFS}, la mejor 
    estrategia.

\section{Conclusiones}
    Dado que sabemos de entrada la altura del árbol en el cual estarán las soluciones nos interesa llegar rápidamente a esa altura. Además, como sabemos que todas ellas serán 
    igualmente "buenas", es decir no hay soluciones mejores que otras, nos basta hallar solamente la primera solución. Por lo tanto, se deduce fácilmente que un algoritmo 
    \textit{DFS} tendrá siempre una perfomance mejor que el resto. \\

    Es interesante ver que un algoritmo de tipo A* con la función de costo trivial y la heurística trivial, se transforma en un \textit{DFS}, al explorar siempre 
    primero en profundidad. \\

\end{document}
