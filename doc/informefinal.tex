\documentclass[a4paper,10pt]{article}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}

\usepackage[utf8]{inputenc}
\usepackage{t1enc}
\usepackage[spanish]{babel}
\usepackage[pdftex,usenames,dvipsnames]{color}
\usepackage[pdftex]{graphicx}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[table]{xcolor}
\usepackage[small,bf]{caption}
\usepackage{float}
\usepackage{subfig}
\usepackage{listings}
\usepackage{bm}
\usepackage{times}

\begin{document}
\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\renewcommand{\lstlistingname}{C\'odigo Fuente}
\lstloadlanguages{Octave} 
\lstdefinelanguage{MyOctave}[]{Octave}{
        deletekeywords={beta,det},
        morekeywords={repmat}
} 
\lstset{
        language=MyOctave,
        stringstyle=\ttfamily,
        showstringspaces = false,
        basicstyle=\footnotesize\ttfamily,
        commentstyle=\color{gray},
        keywordstyle=\bfseries,
        numbers=left,
        numberstyle=\ttfamily\footnotesize,
        stepnumber=1,                   
        framexleftmargin=0.20cm,
        numbersep=0.37cm,              
        backgroundcolor=\color{white},
        showspaces=false,
        showtabs=false,
        frame=l,
        tabsize=4,
        captionpos=b,               
        breaklines=true,             
        breakatwhitespace=false,      
        mathescape=true
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%% begin TITLE PAGE %%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{titlepage}
        \vfill
        \thispagestyle{empty}
        \begin{center}
                \includegraphics{./images/itba_logo.png}
                \vfill
                \Huge{Sistemas de Inteligencia Artificial}\\
                \vspace{1cm}
                \Huge{Métodos de búsqueda no informados y e informados}\\
                \vspace{1cm}
                \Huge{Trabajo Pr\'actico Especial 1}\\
        \end{center}
        \vfill
        \large{
        \begin{tabular}{lcr}
                Civile, Juan Pablo && 50453\\
                Ordano, Esteban && 50753\\
                Crespo, Alvaro && 50758 \\
        \end{tabular}
}
        \vspace{2cm}
        \begin{center}
                \large{25 de marzo de 2013}\\
        \end{center}
\end{titlepage}
\newpage

\setcounter{page}{1}

% \tableofcontents
% \newpage

\section{Descripción del problema}

    \subsection{Definición}

    % TODO: REfactorear esta sección
    % TODO: Cambie algunas cosas pero creo que necesita otro mindset si se quiere refactorear más

    Se define el tablero de juego como una matriz de números enteros, donde cada número representa un tipo de ficha. Números distintos corresponden a tipos de fichas distintas. 
    El objetivo del juego es vaciar el tablero, quitando todas las fichas. Las fichas se sacan de a pares, siempre siendo ambas del mismo tipo, y solamente pueden ser elegibles 
    para ser sacadas del tablero si se encuentran en los bordes izquierdo o derecho del tablero. No hay necesidad de que ambas fichas esten en el mismo borde. Cabe destacar 
    que podría ocurrir que en un determinado momento no haya posibilidad de quitar más fichas. En este caso, el juego se da por perdido.

    \subsection{Modelado}
    \label{problem-info}
    Se representó el proceso del juego como una sucesión de estados que están dispuestos en un grafo dirigido sin ciclos. Los estados están conectados si se puede pasar de uno 
    al otro, haciendo un movimiento del juego \textit{válido}. Teniendo esto en cuenta, el primer nodo de nuestro grafo es el estado inicial, en el que tablero tiene todas sus fichas. 
    Algo que se deduce de este planteo, es que todos los estados que estén a la misma altura $h$, tendrán la misma cantidad de fichas, por que para llegar a él hubo que aplicar 
    la misma cantidad de reglas, $h$. Esto nos lleva a poder afirmar que todas las soluciones estarán a la misma altura (la máxima) y que esta altura es conocida para un 
    tablero de $N$ fichas: es $\frac{N}{2}$, ya que en cada movimiento válido se pueden sacar sólo 2 fichas.

\section{Análisis}

    Debido a la naturaleza del problema, dado el estado inicial se conoce el costo de ruta de la solución (si existe): será igual a la cantidad de fichas en el tablero.

    Otra característica que presenta el problema es que las soluciones son indistintas unas de otras, ya que todas tendrán el mismo costo de ruta. Esto lleva a que no haya una solución más eficiente que otra.

    El grafo de búsqueda es acíclico y dirigido. Dado un estado con dos acciones posibles, tomar una de ellas conduce a otro estado que siempre contará con la acción que no se tomó en su conjunto de acciones posibles. Como corolario de esto, siempre que un estado tenga más de una acción posible (lo cual es muy frecuente, o alcanzar la solución se convierte en un problema trivial), se tendrá más de un camino posible para llegar a una solución, por lo que evitar considerar estados más de una vez es indispensable.

    \subsection{Función de costo}

    La función de costo propuesta consta simplemente de contabilizar la cantidad de piezas que fueron removidas hasta llegar al estado en cuestión. Es decir, toda regla aplicada 
    tiene costo 2. \\

    \subsection{Primer heurística - Ramas angostas}
    
    \[ h(n) = \min \left (\text{\# F}, \Pi_{i=1}^{k} {\# c_i \choose 2} \right )\] 

    Donde:
    \begin{itemize}
        \item $F$ es el conjunto de fichas en el tablero.
        \item $k$ es la cantidad de tipos de fichas.
        \item $c_i$ es el conjunto de fichas de tipo $i$.
    \end{itemize}

    El objetivo de la heurística es explorar aquellas ramas donde menos decisiones se deben tomar. Para lograr esto, se calcula, para cada tipo de fichas, cuántas posibles elecciones hay para eliminarlas. Esto significa, si hay tres fichas en los bordes del mismo tipo, hay tres posibles elecciones de parejas, y el valor de la heurística para ese estado será mayor que para un estado en el cual sólo hay dos fichas del mismo tipo en los bordes.


    Como primer heurística se propuso tomar en cuenta el mínimo entre la cantidad de fichas restantes en el tablero y la productoria de la combinatoria  
    ${N \choose 2}$ siendo N el tamaño de cada uno de los conjuntos de fichas iguales en los bordes izquierdo o derecho.\\

    %TODO: Esto es como medio en el aire...
    La idea trás esta fórmula es recorrer primero las ramas del árbol que tengan más posibilidades de remover fichas.

    Cabe destacar que por definición esta heurística es admisible, ya que nunca sobreestimará el costo de llegar a la solución, el cual, para la función de costo propuesta, es 
    igual a la cantidad de piezas que quedan en el tablero, lo cual es igual al doble de la cantidad de estados que faltan para llegar a la solución.



    siendo N la cantidad de conjuntos de fichas iguales en los bordes.
    
    \subsection{Segunda heurística}

    Como segunda heurística se propuso la sencilla resta entre la cantidad total de fichas restantes en el tablero y la cantidad de fichas con posibilidad de ser retiradas en el
    siguiente movimiento.\\

    De nuevo, por construcción esta heurística es admisible, ya que siempre es menor que el costo de llegar a la solución ($N$).

     \[ h(x) = N - K\] 

    siendo N la cantidad total de fichas restantes en el tablero, y K la cantidad de fichas elegibles para ser retiradas del tablero.

    \subsection{Heurística trivial}

    La heurística trivial en este caso, sería contar la cantidad de fichas que restan sacar del tablero. Esta heurística transforma el algoritmo A* en un simple DFS, 
    ya que siempre exploraría primero los nodos hijos. Esta heurística es igual al costo de llegar a la solución, por lo que puede pensarse como la mejor aproximación posible.

    \[ h(x) = N \] 

    siendo N la cantidad total de fichas restantes en el tablero.

\section{Análisis y resultados}

\subsection{Búsquedas no informadas}

    \subsubsection{Depth First Search}
    \label{sec:dfs}
    Dada las características del problema, este es el algoritmo no informado que mejor se comporta, ya que baja rápidamente por el árbol y tiene más posibilidades de encontrar una solución primero.
    Solución que será la aceptada porque como sabemos, todas las soluciones son igualmente buenas (Ver sección \ref{implementation-details}).\\

    Un estado del tablero puede ser irresoluble si la última pareja de cada uno de dos o más tipos de fichas se encuentran intercaladas.
    De esta manera, el tablero irresoluble de menor cantidad de fichas está formado de una sola línea de forma $ABAB$, con $A$ y $B$ dos tipos de fichas distintos.
    Debe notarse que el hecho de que un estado sea irresoluble, no significa que no tenga estados hijos.
    Puede tener hijos y estos tambien seran irresolubles.
    Cuando esta situación se dá, el DFS expande una gran cantidad de estados que son irresolubles.

    %TODO: insetar datos para backupear esto ya sea antes o despues de las aseveraciones.
    
    \subsubsection{Breath First Search}
    En contraposición con el \textit{DFS}, este algoritmo tiene una perfomance pobre, ya que explora muchos estados de más, al hacer una búsqueda ``a lo ancho''.
    También le juega en contra que para este problema no existe una solución óptima o camino óptimo, o más bien, cualquier solución es óptima, y cualquier camino es óptimo. 
    Por lo cual no nos interesa demorarnos en analizar todos los caminos posibles.

    Se puede constatar esto en la tabla \ref{crappy-best}, donde se muestra el mejor resultado encontrado para el \textit{BFS}.
    En esta tabla vemos que los algoritmos \textit{DFS} y \textit{Greedy} mejoran ampliamente los resultados de este algoritmo.

    \subsubsection{Iterative Deepening}
    Como su definición lo dice, este algoritmo mezcla las características del \textit{DFS} con las del \textit{BFS}, por lo que para este problema, tiene aspectos positivos (los del 
    \textit{DFS}) y también negativos (los del \textit{BFS}). 
    El elemento de \textit{BFS} del algoritmo lo hace menos eficiente que el \textit{DFS}.

\subsection{Búsquedas informadas}
    
    \subsubsection{A*}
    
    La naturaleza de las soluciones al problema hace que el \textit{A*} no sea el mejor algoritmo a aplicar. Al igual que el \textit{BFS}, intenta encontrar la solución de menor costo.
    Pero como todas las soluciones son del mismo costo, esto a veces implica que el algoritmo vuelve sobre sus pasos para analizar un estado de menor costo.
    Y eso lo lleva a dejar para más adelante caminos más cercanos a la solución. \\
    Cabe destacar que en el caso de la heurística trivial, este algoritmo se comporta como un \textit{DFS}.

    En el cuadro \ref{crappy-best} se ve el mejor resultado encontrado para este algoritmo.
    En esta tabla vemos que los algoritmos \textit{DFS} y \textit{Greedy} mejoran ampliamente los resultados de este algoritmo.

    \subsubsection{Greedy Search}
    
    Este algoritmo, por definición, se centra en la heurística elegida y varía su perfomance de acuerdo a ella.
    A diferencia del \textit{A*}, al no tener una funcion de costo no hace backtracking innecesario y con una buena heurística, es un algoritmo adecuado para el problema.

    El siguiente cuadro muestra una comparacion entre 100 ejecuciones de este algoritmo y \textit{DFS}.
    La columna \textbf{Peor} cuenta la cantidad de casos que el \textit{Greedy} con esa heuristica dio un peor resultado.
    De la misma manera, \textbf{Igual} y \textbf{Mejor} muestran respectivamente cuantas veces dio el mismo resultado y un mejor resultado.

    \begin{table}[H]
        \label{greedy-dfs}

        \begin{center}
        \begin{tabular}{l|r|r|r}
            Heuristica & Peor & Igual & Mejor \\
            \hline
            Slim & 49 & 36 & 15 \\
            Fat & 0 & 70 & 30 \\
        \end{tabular}
        \end{center}
        \caption{Comparacion entre \textit{Greedy} y \textit{DFS}}

    \end{table}

    Podemos ver que \textit{Greedy Fat} mejora los resultados del \textit{DFS}.
    Creemos que esto es debido a que el uso de la heuristica le permite evitar los estados irresolubles (Vease la seccion \ref{sec:dfs}).
    Si el cálculo de una función que responda si un tablero es irresoluble fuera eficiente en tiempo y memoria, tal función sería potencialmente una mejor heurística planteada de forma: $h(n_{irresoluble}) = \inf$, $h(n_{no irresoluble}) = \#F$.

\section{Conclusiones}
    Dado que se conoce desde un principio la altura del árbol en el cual estarán las soluciones, interesa llegar rápidamente a esa altura. Además, como se sabe que todas ellas serán 
    igualmente "buenas", es decir no hay soluciones mejores que otras, basta con hallar solamente la primera solución. Por lo tanto, se deduce fácilmente que un algoritmo 
    \textit{DFS} tendrá siempre una perfomance mejor que el resto. \\

    Los resultados de la tabla [INSERT RELEVANT DATA HERE] demuestran esta aseveración. \\

    Es interesante ver que un algoritmo de tipo A* con la función de costo trivial y la heurística trivial, se transforma en un \textit{DFS}, al explorar siempre 
    primero en profundidad. \\

    Los resultados de [INSERT RELEVANT DATA HERE] demuestran esta aseveración. \\

    Otro dato que resulta interesante es que algoritmos reconocidos por brindar caminos óptimos o soluciones óptimas, como \textit{BFS} o \textit{A*}, se encuentran entre las peores
    opciones para este problema en particular. \\

    Esto puede observarse en [INSERT RELEVANT DATA HERE].\\

\include{figures}

\end{document}
